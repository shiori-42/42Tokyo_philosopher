File: ./thread.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   thread.c                                           :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 18:31:05 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 18:46:31 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: 
16: int thread_create(t_program *program)
17: {
18: 
19:     int i = 0;
20: 
21:     if(pthread_create(&program->monitor, NULL, monitor_routine, program->philos)!=0)
22:     {
23:         free_all_memory(program);
24:         return(write(2, "Error: Failed to create monitor thread\n", 39), 1);
25:     }
26: 
27:     while (i < program->num_of_philos)
28:     {
29:         if(pthread_create(&program->philos[i].thread, NULL, philo_routine, &program->philos[i])!=0)
30:         {
31:             free_all_memory(program);
32:             return(write(2, "Error: Failed to create philosopher thread\n", 42), 1);
33:         }
34:         i++;
35:     }
36:     return (0);
37: }
38: 
39: int thread_join(t_program *program) 
40: {
41: 
42:     int i;
43:     
44:     i = 0;
45:     if(pthread_join(program->monitor, NULL)!=0)
46:     {
47:         free_all_memory(program);
48:         return(write(2, "Error: Failed to join monitor thread\n", 36), 1);
49:     }
50:     while (i < program->num_of_philos)
51:     {
52:         if(pthread_join(program->philos[i].thread, NULL)!=0)
53:         {
54:             free_all_memory(program);
55:             return(write(2, "Error: Failed to join philosopher thread\n", 40), 1);
56:         }
57:         i++;
58:     }
59:     return (0);
60: 
61: }
62: 
63: 
64: int must_stop_simulation(t_philo *philo)
65: {
66:     int is_must_stop;
67: 
68:     pthread_mutex_lock(philo->stop_mutex);
69:     is_must_stop = *philo->must_stop;
70:     pthread_mutex_unlock(philo->stop_mutex);
71:     return is_must_stop;
72: }
73: 
74: void print_status(t_philo *philo,char *status)
75: {
76:     pthread_mutex_lock(philo->stop_mutex);
77:     if ((ft_strcmp(status, DIED) == 0)|| !*philo->must_stop)
78:         printf("%ld %d %s\n", get_current_time() - philo->start_time, philo->id, status);
79:     pthread_mutex_unlock(philo->stop_mutex);
80: }
81: 
82: void *philo_routine(void *argv)
83: {
84:     t_philo *philo = (t_philo *)argv;
85:     if(philo->id % 2 == 0)
86:         ft_usleep(1);
87:     while (!must_stop_simulation(philo))
88:     {
89:  
90:         take_forks(philo);
91:         if (philo->num_of_philos == 1)
92:             return NULL;
93:         eating(philo);
94:         put_down_forks(philo);
95:         sleeping(philo);
96:         thinking(philo);
97:     }
98:     // printf("%d exit\n",philo->id);
99:     return NULL;
100: }
101: 

File: ./monitor.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   monitor.c                                          :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:06:14 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 19:22:17 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: int check_any_philosopher_death(t_philo *philos)
16: {
17:     long since_last_meal_time;
18:     int i = 0;
19: 
20:     while (i < philos[0].num_of_philos)
21:     {
22:         pthread_mutex_lock(philos[0].time_mutex);
23:         since_last_meal_time = get_current_time() - philos[i].last_meal_time;
24:         pthread_mutex_unlock(philos[0].time_mutex);
25:         
26:         if (since_last_meal_time >= philos[i].time_to_die)
27:         {
28:             pthread_mutex_lock(philos[0].stop_mutex);
29:             *philos[0].must_stop = true;
30:             pthread_mutex_unlock(philos[0].stop_mutex);
31:             print_status(&philos[i], DIED);
32:             return (1);
33:         }
34:         i++;
35:     }
36:     return (0);
37: }
38: 
39: 
40: int check_all_philosophers_ate(t_philo *philos)
41: {
42:     int i = 0;
43:     int ate_count = 0;
44: 
45:     if (philos[0].must_eat_count == -1)
46:         return (0);
47:     
48:     pthread_mutex_lock(philos[0].eat_mutex);
49:     while (i < philos[0].num_of_philos)
50:     {
51:         if (philos[i].eat_count == philos[i].must_eat_count)
52:             ate_count++;
53:         i++
54:     }
55:     pthread_mutex_unlock(philos[0].eat_mutex);
56: 
57:     if (ate_count == philos[0].num_of_philos)
58:     {
59:         pthread_mutex_lock(philos[0].stop_mutex);
60:         *(philos[0].must_stop) = true;
61:         pthread_mutex_unlock(philos[0].stop_mutex);
62:         return (1);
63:     }
64:     return (0);
65: }
66:    
67: void *monitor_routine(void *argv)
68: {
69:     t_philo *philos = (t_philo *)argv;
70:     while (1)
71:     {
72:         if (check_any_philosopher_death(philos))
73:             break; 
74:         if (check_all_philosophers_ate(philos))
75:             break; 
76:         ft_usleep(200);
77:     }
78:     // printf("monitor end\n");
79:     pthread_exit(NULL);
80: }
81: 
82: 
83: 
84:  

File: ./init.c
1: // /* ************************************************************************** */
2: // /*                                                                            */
3: // /*                                                        :::      ::::::::   */
4: // /*   init.c                                             :+:      :+:    :+:   */
5: // /*                                                    +:+ +:+         +:+     */
6: // /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: // /*                                                +#+#+#+#+#+   +#+           */
8: // /*   Created: 2025/02/16 17:05:55 by shiori            #+#    #+#             */
9: // /*   Updated: 2025/02/16 18:21:49 by shiori           ###   ########.fr       */
10: // /*                                                                            */
11: // /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: void	set_philo_input(t_program *program,t_philo *philo, char **argv, int i)
16: {
17: 	philo->num_of_philos = ft_atoi(argv[1]);
18: 	philo->time_to_die = ft_atoi(argv[2]);
19: 	philo->time_to_eat = ft_atoi(argv[3]);
20: 	philo->time_to_sleep = ft_atoi(argv[4]);
21: 	if (argv[5])
22: 		philo->must_eat_count = ft_atoi(argv[5]);
23: 	else
24:         philo->must_eat_count = -1;
25:     philo->id = i + 1;
26:     philo->eat_count = 0;
27:     philo->start_time = get_current_time();
28:     philo->last_meal_time = get_current_time();
29:     philo->must_stop = &program->must_stop;
30:     philo->stop_mutex = &program->stop_mutex;
31:     philo->eat_mutex = &program->eat_mutex;
32:     philo->time_mutex = &program->time_mutex;
33:     philo->left_fork = &program->forks[i];
34:     philo->right_fork = &program->forks[(i-1 + philo->num_of_philos) % philo->num_of_philos];
35: }
36: 
37: void	init_philos(t_program *program, char **argv)
38: {
39: 	int	i;
40: 
41: 	i = 0;
42:     while (i < program->num_of_philos)
43: 	{
44:         set_philo_input(program,&program->philos[i], argv,i);
45: 		i++;
46: 	}
47: }
48: 
49: static int init_basic_mutexes(t_program *program)
50: {
51:     if (pthread_mutex_init(&program->stop_mutex, NULL) != 0)
52:         return (free_all_memory(program), 1);
53:     program->stop_mutex_init = true;
54: 
55:     if (pthread_mutex_init(&program->eat_mutex, NULL) != 0)
56:         return (free_all_memory(program), 1);
57:     program->eat_mutex_init = true;
58: 
59:     if (pthread_mutex_init(&program->time_mutex, NULL) != 0)
60:         return (free_all_memory(program), 1);
61:     program->time_mutex_init = true;
62: 
63:     return (0);
64: }
65: 
66: int init_mutex(t_program *program)
67: {
68:     int i;
69:     
70:     if (init_basic_mutexes(program))
71:         return (1);
72: 
73:     program->forks = malloc(sizeof(pthread_mutex_t) * program->num_of_philos);
74:     program->forks_init = malloc(sizeof(bool) * program->num_of_philos);
75:     if (!program->forks || !program->forks_init)
76:         return (free_all_memory(program), 1);
77:     
78:     i = 0;
79:     while (i < program->num_of_philos)
80:     {
81:         program->forks_init[i] = false;
82:         if (pthread_mutex_init(&program->forks[i], NULL) != 0)
83:             return (free_all_memory(program), 1);
84:         program->forks_init[i] = true;
85:         i++;
86:     }
87:     return (0);
88: }
89: 
90: void init_program(t_program *program, char **argv)
91: {
92:     program->num_of_philos = ft_atoi(argv[1]);
93:     program->must_stop = false;
94:     program->philos = malloc(sizeof(t_philo) * program->num_of_philos);
95:     program->stop_mutex_init = false;
96:     program->eat_mutex_init = false;
97:     program->time_mutex_init = false;
98: }
99: 
100: 
101: 
102: 
103: 

File: ./utils.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   utils.c                                            :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:10:04 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 19:01:15 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: long	get_current_time(void)
16: {
17: 	struct timeval	time;
18: 
19: 	if (gettimeofday(&time, NULL) == -1)
20: 		write(2, "gettimeofday() error\n", 22);
21: 	return (time.tv_sec * 1000 + time.tv_usec / 1000);
22: }
23: 
24: int	ft_usleep(long milliseconds)
25: {
26: 	long	start;
27: 
28: 	start = get_current_time();
29: 	while ((get_current_time() - start) < milliseconds)
30: 		usleep(500);
31: 	return (0);
32: }
33: 
34: static void destroy_basic_mutexes(t_program *program)
35: {
36:     if (program->stop_mutex_init)
37:         pthread_mutex_destroy(&program->stop_mutex);
38:     if (program->eat_mutex_init)
39:         pthread_mutex_destroy(&program->eat_mutex);
40:     if (program->time_mutex_init)
41:         pthread_mutex_destroy(&program->time_mutex);
42: }
43: 
44: void free_all_memory(t_program *program)
45: {
46:     int i;
47: 
48:     destroy_basic_mutexes(program);
49: 
50:     if (program->forks && program->forks_init)
51:     {
52:         i = 0;
53:         while (i < program->num_of_philos)
54:         {
55:             if (program->forks_init[i])
56:                 pthread_mutex_destroy(&program->forks[i]);
57:             i++;
58:         }
59:         free(program->forks_init);
60:     }
61:     if (program->forks)
62:         free(program->forks);
63:     if (program->philos)
64:         free(program->philos);
65: }
66: 
67: 

File: ./main.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   main.c                                             :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:06:04 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 18:59:19 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: int validate_command_line_args(char **argv)
16: {
17:     if (ft_atoi(argv[1]) <= 0 || ft_atoi(argv[2]) <= 0 ||
18:         ft_atoi(argv[3]) <= 0 || ft_atoi(argv[4]) <= 0 || ((argv[5] && ft_atoi(argv[5]) <= 0)))
19:         return (1);
20:     return (0);
21: }
22: 
23: int main(int argc, char **argv)
24: {
25:     t_program program;
26: 
27:     if (argc != 5 && argc != 6)
28:         return (write(2, "Error: Wrong argument count\n", 28), 1);
29:     if (validate_command_line_args(argv) == 1)
30:         return (write(2, "Error: Invalid argument\n", 24), 1);
31:     init_program(&program, argv);
32:     if (!program.philos)
33:         return (write(2, "Error: Philosopher memory allocation failed\n", 24), 1);
34:     if(init_mutex(&program))
35:         return (write(2, "Error: Mutex initialization failed\n", 24), 1);
36: 	init_philos(&program, argv);
37:     if(thread_create(&program))
38:         return (write(2, "Error: Thread creation failed\n", 24), 1);
39:     if(thread_join(&program))
40:         return (write(2, "Error: Thread join failed\n", 24), 1);
41:     free_all_memory(&program);
42:     return (0);
43: }
44: 

File: ./philo_routine.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   philo_routine.c                              :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:06:11 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/16 17:07:23 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: void thinking(t_philo *philo)
16: {
17:     print_status(philo, THINKING);
18: }
19: void sleeping(t_philo *philo)
20: {
21:     print_status(philo, SLEEPING);
22:     ft_usleep(philo->time_to_sleep);
23: }
24: 
25: void take_forks(t_philo *philo)
26: {
27: 
28:     if (philo->num_of_philos == 1)
29:     {
30:         pthread_mutex_lock(philo->right_fork);
31:         print_status(philo, FORK_TAKEN);
32:         ft_usleep(philo->time_to_die);
33:         pthread_mutex_unlock(philo->right_fork);
34:         return ;
35:     }
36:         pthread_mutex_lock(philo->right_fork);
37:         pthread_mutex_lock(philo->left_fork);
38:     print_status(philo, FORK_TAKEN);
39:     print_status(philo, FORK_TAKEN);
40: }
41: 
42: void eating(t_philo *philo)
43: {
44: 
45:     pthread_mutex_lock(philo->time_mutex);
46:     philo->last_meal_time = get_current_time();
47:     pthread_mutex_unlock(philo->time_mutex);
48:     print_status(philo, EATING);
49:     ft_usleep(philo->time_to_eat);
50:     pthread_mutex_lock(philo->eat_mutex);
51:     philo->eat_count++;
52:     // printf("philo id %d:philo->eat_count: %d\n", philo->id,philo->eat_count);
53:     pthread_mutex_unlock(philo->eat_mutex);
54: 
55: }
56: 
57: void put_down_forks(t_philo *philo)
58: {
59:     pthread_mutex_unlock(philo->left_fork);
60:     pthread_mutex_unlock(philo->right_fork);
61: }

File: ./libft.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   libft.c                                            :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/23 19:01:00 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 19:06:19 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: int	ft_strcmp(char *s1, char *s2)
14: {
15: 	int	i;
16: 
17: 	i = 0;
18: 	while (s1[i] || s2[i])
19: 	{
20: 		if ((s1[i] != s2[i] || !s1[i] || !s2[i]))
21: 			return (s1[i] - s2[i]);
22: 		i++;
23: 	}
24: 	return (0);
25: }
26: int ft_atoi(char *str)
27: {
28:     int i=0;
29:     int sign=1;
30:     int result=0;
31:   
32:     if(str[i]=='-' || str[i]=='+')
33:     {
34:         if(str[i]=='-')
35:             sign=-1;
36:         i++;
37:     }
38:     while(str[i]>='0' && str[i]<='9')
39:     {
40:         result=result*10+(str[i]-'0');
41:         i++;
42:     } 
43:     return (sign*result);
44: }

