File: ./thread.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   thread.c                                           :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 18:31:05 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 03:44:11 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: 
16: int thread_create(t_program *program)
17: {
18: 
19:     int i = 0;
20: 
21:     if(pthread_create(&program->monitor, NULL, monitor_routine, program->philos)!=0)
22:     {
23:         free_all_memory(program);
24:         return(write(2, "Error: Failed to create monitor thread\n", 39), 1);
25:     }
26: 
27:     while (i < program->num_of_philos)
28:     {
29:         if(pthread_create(&program->philos[i].thread, NULL, philo_routine, &program->philos[i])!=0)
30:         {
31:             free_all_memory(program);
32:             return(write(2, "Error: Failed to create philosopher thread\n", 42), 1);
33:         }
34:         i++;
35:     }
36:     return (0);
37: }
38: 
39: int thread_join(t_program *program) 
40: {
41: 
42:     int i;
43:     
44:     i = 0;
45:     if(pthread_join(program->monitor, NULL)!=0)
46:     {
47:         free_all_memory(program);
48:         return(write(2, "Error: Failed to join monitor thread\n", 36), 1);
49:     }
50:     while (i < program->num_of_philos)
51:     {
52:         if(pthread_join(program->philos[i].thread, NULL)!=0)
53:         {
54:             free_all_memory(program);
55:             return(write(2, "Error: Failed to join philosopher thread\n", 40), 1);
56:         }
57:         i++;
58:     }
59:     return (0);
60: 
61: }
62: 
63: 
64: int must_stop_simulation(t_philo *philo)
65: {
66:     int is_must_stop;
67: 
68:     pthread_mutex_lock(philo->stop_mutex);
69:     is_must_stop = *philo->must_stop;
70:     pthread_mutex_unlock(philo->stop_mutex);
71:     return is_must_stop;
72: }
73: 
74: void print_status(t_philo *philo,char *status)
75: {
76:     pthread_mutex_lock(philo->stop_mutex);
77:     if ((ft_strcmp(status, DIED) == 0)|| !*philo->must_stop)
78:         printf("%ld %d %s\n", get_current_time() - philo->start_time, philo->id, status);
79:     pthread_mutex_unlock(philo->stop_mutex);
80: }
81: 
82: void *philo_routine(void *argv)
83: {
84:     t_philo *philo = (t_philo *)argv;
85:     if(philo->id % 2 == 0)
86:         ft_usleep(1);
87:     while (!must_stop_simulation(philo))
88:     {
89:  
90:         take_forks(philo);
91:         eating(philo);
92:         put_down_forks(philo);
93:         sleeping(philo);
94:         thinking(philo);
95:     }
96:     printf("%d exit\n",philo->id);
97:     return NULL;
98: }
99: 

File: ./monitor.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   monitor.c                                          :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:06:14 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 12:09:56 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: int check_any_philosopher_death(t_philo *philos)
16: {
17:     long since_last_meal_time;
18:     int i = 0;
19: 
20:     while (i < philos[0].num_of_philos)
21:     {
22:         pthread_mutex_lock(philos[0].time_mutex);
23:         since_last_meal_time = get_current_time() - philos[i].last_meal_time;
24:         pthread_mutex_unlock(philos[0].time_mutex);
25:         
26:         if (since_last_meal_time >= philos[i].time_to_die)
27:         {
28:             print_status(&philos[i], DIED);
29:             pthread_mutex_lock(philos[0].stop_mutex);
30:             *philos[0].must_stop = true;
31:             pthread_mutex_unlock(philos[0].stop_mutex);
32:             return (1);
33:         }
34:         i++;
35:     }
36:     return (0);
37: }
38: 
39: 
40: int check_all_philosophers_ate(t_philo *philos)
41: {
42:     int i;
43:     int ate_count;
44: 
45:     ate_count = 0;
46:     if (philos[0].must_eat_count == -1)
47:         return (0);
48:     i = 0;
49:     while (i < philos[0].num_of_philos)
50:     {
51:         pthread_mutex_lock(philos[0].eat_mutex);
52:         if (philos[i].eat_count == philos[i].must_eat_count)
53:             ate_count++;
54:         pthread_mutex_unlock(philos[0].eat_mutex);
55:         if (ate_count == philos[0].num_of_philos)
56:         {
57:             pthread_mutex_lock(philos[0].stop_mutex);
58:             *(philos[0].must_stop) = true;
59:             pthread_mutex_unlock(philos[0].stop_mutex);
60:             return (1);
61:         }
62:         i++;
63:     }
64:     return (0);
65: }
66:    
67: void *monitor_routine(void *argv)
68: {
69:     t_philo *philos = (t_philo *)argv;
70:     while (1)
71:     {
72:         if (check_any_philosopher_death(philos))
73:             break; 
74:         if (check_all_philosophers_ate(philos))
75:             break; 
76:         ft_usleep(200);
77:     }
78:     printf("monitor end\n");
79:     pthread_exit(NULL);
80: }
81: 
82: 
83: 
84:  

File: ./init.c
1: // /* ************************************************************************** */
2: // /*                                                                            */
3: // /*                                                        :::      ::::::::   */
4: // /*   init.c                                             :+:      :+:    :+:   */
5: // /*                                                    +:+ +:+         +:+     */
6: // /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: // /*                                                +#+#+#+#+#+   +#+           */
8: // /*   Created: 2025/02/16 17:05:55 by shiori            #+#    #+#             */
9: // /*   Updated: 2025/02/16 18:21:49 by shiori           ###   ########.fr       */
10: // /*                                                                            */
11: // /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: void	set_philo_input(t_program *program,t_philo *philo, char **argv, int i)
16: {
17: 	philo->num_of_philos = ft_atoi(argv[1]);
18: 	philo->time_to_die = ft_atoi(argv[2]);
19: 	philo->time_to_eat = ft_atoi(argv[3]);
20: 	philo->time_to_sleep = ft_atoi(argv[4]);
21: 	if (argv[5])
22: 		philo->must_eat_count = ft_atoi(argv[5]);
23: 	else
24:         philo->must_eat_count = -1;
25:     philo->id = i + 1;
26:     philo->eat_count = 0;
27:     philo->start_time = get_current_time();
28:     philo->last_meal_time = get_current_time();
29:     philo->must_stop = &program->must_stop;
30:     philo->stop_mutex = &program->stop_mutex;
31:     philo->eat_mutex = &program->eat_mutex;
32:     philo->time_mutex = &program->time_mutex;
33:     philo->left_fork = &program->forks[i];
34:     philo->right_fork = &program->forks[(i-1 + philo->num_of_philos) % philo->num_of_philos];
35: }
36: 
37: void	init_philos(t_program *program, char **argv)
38: {
39: 	int	i;
40: 
41: 	i = 0;
42:     while (i < program->num_of_philos)
43: 	{
44:         set_philo_input(program,&program->philos[i], argv,i);
45: 		i++;
46: 	}
47: }
48: 
49: int init_mutex(t_program *program)
50: {
51:     int i;
52:     
53:     if (pthread_mutex_init(&program->stop_mutex, NULL) != 0)
54:         return (free_all_memory(program), 1);
55:     program->stop_mutex_init = true;
56: 
57:     if (pthread_mutex_init(&program->eat_mutex, NULL) != 0)
58:         return (free_all_memory(program), 1);
59:     program->eat_mutex_init = true;
60: 
61:     if (pthread_mutex_init(&program->time_mutex, NULL) != 0)
62:         return (free_all_memory(program), 1);
63:     program->time_mutex_init = true;
64: 
65:     program->forks = malloc(sizeof(pthread_mutex_t) * program->num_of_philos);
66:     program->forks_init = malloc(sizeof(bool) * program->num_of_philos);
67:     if (!program->forks || !program->forks_init)
68:         return (free_all_memory(program), 1);
69:     
70:     i = 0;
71:     while (i < program->num_of_philos)
72:     {
73:         program->forks_init[i] = false;
74:         if (pthread_mutex_init(&program->forks[i], NULL) != 0)
75:             return (free_all_memory(program), 1);
76:         program->forks_init[i] = true;
77:         i++;
78:     }
79:     return (0);
80: }
81: 
82: void init_program(t_program *program, char **argv)
83: {
84:     program->num_of_philos = ft_atoi(argv[1]);
85:     program->must_stop = false;
86:     program->philos = malloc(sizeof(t_philo) * program->num_of_philos);
87:     program->stop_mutex_init = false;
88:     program->eat_mutex_init = false;
89:     program->time_mutex_init = false;
90: }
91: 
92: 
93: 
94: 
95: 

File: ./utils.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   utils.c                                            :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:10:04 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 03:03:11 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: long	get_current_time(void)
16: {
17: 	struct timeval	time;
18: 
19: 	if (gettimeofday(&time, NULL) == -1)
20: 		write(2, "gettimeofday() error\n", 22);
21: 	return (time.tv_sec * 1000 + time.tv_usec / 1000);
22: }
23: 
24: int	ft_usleep(long milliseconds)
25: {
26: 	long	start;
27: 
28: 	start = get_current_time();
29: 	while ((get_current_time() - start) < milliseconds)
30: 		usleep(500);
31: 	return (0);
32: }
33: 
34: int	ft_strlen(char *str)
35: {
36: 	int	i;
37: 
38: 	i = 0;
39: 	while (str[i])
40: 		i++;
41: 	return (i);
42: }
43: 
44: int	ft_strcmp(char *s1, char *s2)
45: {
46: 	size_t	i;
47: 
48: 	i = 0;
49: 	while (s1[i] || s2[i])
50: 	{
51: 		if ((s1[i] != s2[i] || !s1[i] || !s2[i]))
52: 			return (s1[i] - s2[i]);
53: 		i++;
54: 	}
55: 	return (0);
56: }
57: 
58: 
59: void free_all_memory(t_program *program)
60: {
61:     int i;
62: 
63:     if (program->stop_mutex_init)
64:         pthread_mutex_destroy(&program->stop_mutex);
65:     if (program->eat_mutex_init)
66:         pthread_mutex_destroy(&program->eat_mutex);
67:     if (program->time_mutex_init)
68:         pthread_mutex_destroy(&program->time_mutex);
69: 
70:     if (program->forks && program->forks_init)
71:     {
72:         i = 0;
73:         while (i < program->num_of_philos)
74:         {
75:             if (program->forks_init[i])
76:                 pthread_mutex_destroy(&program->forks[i]);
77:             i++;
78:         }
79:         free(program->forks_init);
80:     }
81:     if (program->forks)
82:         free(program->forks);
83:     if (program->philos)
84:         free(program->philos);
85: }
86: 
87: int ft_atoi(char *str)
88: {
89:     int i=0;
90:     int sign=1;
91:     int result=0;
92:   
93:     if(str[i]=='-' || str[i]=='+')
94:     {
95:         if(str[i]=='-')
96:             sign=-1;
97:         i++;
98:     }
99:     while(str[i]>='0' && str[i]<='9')
100:     {
101:         result=result*10+(str[i]-'0');
102:         i++;
103:     } 
104:     return (sign*result);
105: }

File: ./main.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   main.c                                             :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:06:04 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/23 13:24:58 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: int validate_command_line_args(char **argv)
16: {
17:     if (ft_atoi(argv[1]) <= 0 || ft_atoi(argv[2]) <= 0 ||
18:         ft_atoi(argv[3]) <= 0 || ft_atoi(argv[4]) <= 0 || ((argv[5] && ft_atoi(argv[5]) <= 0)))
19:         return (1);
20:     return (0);
21: }
22: 
23: 
24: 
25: #include <signal.h>
26: 
27: int main(int argc, char **argv)
28: {
29:     t_program program;
30: 
31:     if (argc != 5 && argc != 6)
32:         return (write(2, "Error: Wrong argument count\n", 28), 1);
33:     if (validate_command_line_args(argv) == 1)
34:         return (write(2, "Error: Invalid argument\n", 24), 1);
35:     init_program(&program, argv);
36:     if (!program.philos)
37:         return (write(2, "Error: Philosopher memory allocation failed\n", 24), 1);
38:     if(init_mutex(&program))
39:         return (write(2, "Error: Mutex initialization failed\n", 24), 1);
40: 	init_philos(&program, argv);
41:     if(thread_create(&program))
42:         return (write(2, "Error: Thread creation failed\n", 24), 1);
43:     if(thread_join(&program))
44:         return (write(2, "Error: Thread join failed\n", 24), 1);
45:     free_all_memory(&program);
46:     return (0);
47: }
48: 

File: ./philo_routine.c
1: /* ************************************************************************** */
2: /*                                                                            */
3: /*                                                        :::      ::::::::   */
4: /*   philo_routine.c                              :+:      :+:    :+:   */
5: /*                                                    +:+ +:+         +:+     */
6: /*   By: shiori <shiori@student.42.fr>              +#+  +:+       +#+        */
7: /*                                                +#+#+#+#+#+   +#+           */
8: /*   Created: 2025/02/16 17:06:11 by shiori            #+#    #+#             */
9: /*   Updated: 2025/02/16 17:07:23 by shiori           ###   ########.fr       */
10: /*                                                                            */
11: /* ************************************************************************** */
12: 
13: #include "philo.h"
14: 
15: void thinking(t_philo *philo)
16: {
17:     print_status(philo, THINKING);
18: }
19: void sleeping(t_philo *philo)
20: {
21:     print_status(philo, SLEEPING);
22:     ft_usleep(philo->time_to_sleep);
23: }
24: 
25: void take_forks(t_philo *philo)
26: {
27: 
28:     if (philo->num_of_philos == 1)
29:     {
30:         pthread_mutex_lock(philo->right_fork);
31:         print_status(philo, FORK_TAKEN);
32:         ft_usleep(philo->time_to_die);
33:         pthread_mutex_unlock(philo->right_fork);
34:         return ;
35:     }
36:     // if(philo->id % 2 == 0)
37:     // {
38:         // ft_usleep(1);
39:         pthread_mutex_lock(philo->right_fork);
40:         pthread_mutex_lock(philo->left_fork);
41:     // }
42:     // else
43:     // {
44:         // pthread_mutex_lock(philo->left_fork);
45:         // pthread_mutex_lock(philo->right_fork);
46:     // }
47:     print_status(philo, FORK_TAKEN);
48:     print_status(philo, FORK_TAKEN);
49: }
50: 
51: void eating(t_philo *philo)
52: {
53:     pthread_mutex_lock(philo->time_mutex);
54:     philo->last_meal_time = get_current_time();
55:     pthread_mutex_unlock(philo->time_mutex);
56: 
57:     print_status(philo, EATING);
58: 
59:     pthread_mutex_lock(philo->eat_mutex);
60:     philo->eat_count++;
61:     pthread_mutex_unlock(philo->eat_mutex);
62: 
63:     ft_usleep(philo->time_to_eat);
64: }
65: 
66: 
67: void put_down_forks(t_philo *philo)
68: {
69:     pthread_mutex_unlock(philo->left_fork);
70:     pthread_mutex_unlock(philo->right_fork);
71: }

